  include "VECTORS.f90"
  module LATTICE
    !###############################################################
    !     PROGRAM  : LATTICE
    !     TYPE     : Module
    !     PURPOSE  : Setup a 2D square lattice structure. 
    !     COMMENTS : with some linear algebra can be generalized to
    ! any lattice structure. 
    !     TODO     : exploit fortran2003 extensions to include 
    ! more (and less) dimensional vector type with class properties
    !     AUTHORS  : Adriano Amaricci
    !###############################################################
    USE VECTORS
    implicit none
    private

    !Total number of k-points
    !=========================================================
    integer,public                :: Lk

    !parameters:
    !=========================================================
    real(8),parameter,public      :: alat=1.d0 !lattice constant

    !Dispersion relations arrays:
    !=========================================================  
    real(8),dimension(:),allocatable,public   :: epsik,sorted_epsik
    integer,dimension(:),allocatable,public   :: sorted_ik              
    real(8),dimension(:,:),allocatable,public :: epsikt

    !non-interacting Density of states:
    !=========================================================  
    real(8),dimension(:),allocatable,public   :: nnint_dos

    !k-grid:
    !=========================================================
    type(vect2D),dimension(:,:),allocatable,public :: kgrid
    integer,allocatable,dimension(:,:),public      :: kindex
    integer,allocatable,dimension(:),public        :: ik2ix,ik2iy

    !R-grid:
    !=========================================================
    type(vect2D),dimension(:,:),allocatable,public :: rgrid
    integer,allocatable,dimension(:,:),public      :: rindex
    integer,allocatable,dimension(:),public        :: ir2ix,ir2iy


    !MGXM path in k-grid:
    !=========================================================
    type(vect2D),dimension(:),allocatable,public   :: kgrid_MGXMpath
    real(8),allocatable,dimension(:),public        :: MGXMpath
    integer,allocatable,dimension(:),public        :: ik2ix_MGXMpath,ik2iy_MGXMpath

    !wights && accessory functions:
    !=========================================================
    real(8)                                   :: t_hopping,t_prime
    real(8),allocatable,dimension(:),public   :: wt


    public :: sum_overk_zeta
    public :: build_2DSquareLattice
    public :: get_epsik,get_epsikt
    public :: epsk,velocity
    public :: get_reduxGrid_dimension,get_reduxGrid_index,get_reduxGrid_epsik
    public :: get_MGXMpath_dimension,get_MGXMpath
    !public :: get_DOS

  contains

    !+-------------------------------------------------------------------+
    !PROGRAM  : update_g0
    !TYPE     : function
    !PURPOSE  : Evaluate the 2^nd-order perturbation theory self-energy
    !+-------------------------------------------------------------------+
    function sum_overk_zeta(zeta,ek,wk) result(fg)
      complex(8)           :: zeta,fg
      real(8),dimension(:) :: ek,wk
      fg=sum(wk(:)/(zeta-ek(:)))
    end function sum_overk_zeta
    !******************************************************************
    !******************************************************************
    !******************************************************************




    !+-----------------------------------------------------------------+
    !PROGRAM  : BuildLattice
    !TYPE     : Subroutine
    !PURPOSE  : Build the Lattice structure of the problem
    !+-----------------------------------------------------------------+
    subroutine build_2DSquareLattice(Nx,Ny,Nk)
      implicit none
      integer,intent(in)          :: Nx
      integer,optional,intent(in) :: Ny
      integer,intent(out)         :: Nk   
      integer   :: ik,ir,ix,iy,Nk1,Nk2,Lk
      real(8)   :: peso 
      real(8)   :: Kx,Ky,Rx,Ry

      !Versori dello spazio reale (ai,aj) e spazio-k (bi,bj)
      type(vect2D) :: ai,aj,bi,bj
      real(8),parameter :: pi_=3.14159265358979d0
      real(8),parameter :: pi2_=6.28318530717959d0

      Nk1=Nx
      Nk2=Nk1/2+1
      Lk=Nk2*(Nk2+1)/2
      if(present(Ny))Lk=(Nx+1)*(Ny+1)

      if(.not.present(Ny))then
         write(*,"(A,I8,A)")"Red. BZ:",Lk," k-points"
      else
         write(*,"(A,I8,A)")"Full BZ:",Lk," k-points"
      endif
      print*,""

      !Get real lattice basis vectors 
      ai=alat*Xver ; aj=alat*Yver

      !Get reciprocal latice basis vectors
      bi=(pi2_/alat)*Xver ; bj=(pi2_/alat)*Yver

      !Build the k-points grid
      if(present(Ny))then
         call build_full_reciprocal_lattice()
      else
         call build_reduced_reciprocal_lattice() 
      endif
      Nk=Lk

      !Build the Real lattice R-grid
      if(present(Ny))call build_full_real_lattice()

      !Dump lattice structures:
      call plot_real_lattice(ai,aj,rgrid)
      call plot_reciprocal_lattice(bi,bj,kgrid)
      call system("if [ ! -d LATTICEinfo ]; then mkdir LATTICEinfo; fi")
      call system("mv *.lattice LATTICEinfo/ 2>/dev/null")

      !-------------------------
    contains
      !-------------------------
      subroutine build_full_reciprocal_lattice()
        allocate(kindex(0:Nx,0:Ny),kgrid(0:Nx,0:Ny)) 
        allocate(ik2ix(Lk),ik2iy(Lk),wt(Lk))
        ik2ix=0 ; ik2iy=0 ; wt=0.d0
        kgrid=Vzero
        ik=0
        do ix=0,Nx
           do iy=0,Ny
              ik=ik+1
              Kx=dble(ix)/dble(Nx+1)
              Ky=dble(iy)/dble(Ny+1)

              ik2ix(ik)=ix
              ik2iy(ik)=iy
              kindex(ix,iy)=ik

              kgrid(ix,iy)=Kx*bi + Ky*bj  - pi_*Vone 
           enddo
        enddo
        wt=1.d0/dble(Lk)
      end subroutine build_full_reciprocal_lattice
      !-------------------------

      !-------------------------
      subroutine build_reduced_reciprocal_lattice()
        allocate(kindex(0:Nk2,0:Nk2),kgrid(0:Nk2,0:Nk2))
        allocate(ik2ix(Lk),ik2iy(Lk),wt(Lk))
        ik2ix=0 ; ik2iy=0 ; wt=0.d0
        kgrid=Vzero
        ik=0
        do ix=0,Nk1/2
           do iy=0,ix          
              ik=ik+1
              Kx=dble(ix)/dble(Nk1)
              Ky=dble(iy)/dble(Nk1)
              ik2ix(ik)=ix
              ik2iy(ik)=iy
              kgrid(ix,iy)=Kx*bi + Ky*bj - pi_*Vone 
              kindex(ix,iy)=ik
              if (ix==0) then
                 peso=1.d0       !center
              elseif(ix==Nk1/2) then
                 if (iy==0) then
                    peso=2.d0    ! point (pi,0)
                 elseif(iy==Nk1/2) then 
                    peso=1.d0    ! corner 
                 else
                    peso=4.d0    ! border
                 endif
              else
                 if (iy==ix) then
                    peso=4.d0    ! diagonal
                 elseif (iy==0) then
                    peso=4.d0    ! x-axis
                 else
                    peso=8.d0    ! all other points
                 endif
              endif
              wt(ik)=peso/dble(Nk1**2)
           enddo
        enddo
      end subroutine build_reduced_reciprocal_lattice
      !-------------------------

      !-------------------------
      subroutine build_full_real_lattice()
        integer :: Nr
        allocate(rindex(0:Nx,0:Ny),rgrid(0:Nx,0:Ny)) 
        allocate(ir2ix(Lk),ir2iy(Lk))
        rgrid=Vzero
        ir=0
        do ix=0,Nx
           do iy=0,Ny
              ir=ir+1
              Rx=dble(ix)*3/dble(Nx+1) !10 celle
              Ry=dble(iy)*3/dble(Ny+1) !10 celle
              ir2ix(ir)=ix
              ir2iy(ir)=iy
              rindex(ix,iy)=ir
              rgrid(ix,iy)=Rx*ai + Ry*aj
           enddo
        enddo
      end subroutine build_full_real_lattice
      !-------------------------
    end subroutine Build_2DSquareLattice
    !***************************************************************
    !***************************************************************
    !***************************************************************




    !+-----------------------------------------------------------------+
    !PROGRAM  : 
    !TYPE     : Subroutine
    !PURPOSE  :   
    !Build dispersion relation arrays:
    !\epsilon(\ka)          =epsk(i)
    !+-----------------------------------------------------------------+
    subroutine get_epsik(epsik,ts,tsp,sorted_epsik,sorted_ik)
      integer                                    :: ik,ix,iy,it,Lk_
      real(8),intent(in)                         :: ts
      real(8),dimension(:),intent(inout)         :: epsik
      real(8),intent(in),optional                :: tsp
      real(8),dimension(size(epsik)),optional    :: sorted_epsik
      integer,dimension(size(epsik)),optional    :: sorted_ik
      Lk_=size(epsik) !Number of K-points stored in epsik    
      t_hopping=ts    !Set the hopping in common to espk/velocity functions
      t_prime  =0.d0 ; if(present(tsp))t_prime=tsp
      do ik=1,Lk_
         ix=ik2ix(ik)
         iy=ik2iy(ik)
         epsik(ik)=epsk(kgrid(ix,iy))
      enddo
      call get_DOS(epsik,'DOSfree.lattice',wt)
      call system("if [ ! -d LATTICEinfo ]; then mkdir LATTICEinfo; fi")
      call system("mv *.lattice LATTICEinfo/ 2>/dev/null")
      if(present(sorted_epsik).AND.present(sorted_ik))then
         sorted_epsik=epsik;call sort(sorted_epsik,sorted_ik)
      elseif(present(sorted_epsik))then
         sorted_epsik=epsik;call sort(sorted_epsik)
      endif
    end subroutine get_epsik
    !***************************************************************
    !***************************************************************
    !***************************************************************







    !+-----------------------------------------------------------------+
    !PROGRAM  : 
    !TYPE     : Subroutine
    !PURPOSE  : 
    !+-----------------------------------------------------------------+
    subroutine get_epsikt(epsikt_,Ek_,t_)
      real(8),dimension(:,:),intent(inout) :: epsikt_
      real(8),dimension(0:),intent(in)     :: t_
      type(vect2D),intent(in)              :: Ek_
      type(vect2D)                         :: kt
      integer                              :: ik,ix,iy,it,Lk_,Nt
      Lk_= size(epsikt_,2)
      Nt = size(t_)-1
      do it=0,size(t_)-1    
         do ik=1,Lk_
            ix=ik2ix(ik)
            iy=ik2iy(ik)
            kt=kgrid(ix,iy) + t_(it)*Ek_
            epsikt_(it,ik)=epsk(kt)
         enddo
      enddo
      return
    end subroutine get_epsikt
    !***************************************************************
    !***************************************************************
    !***************************************************************




    !+-----------------------------------------------------------------+
    !PROGRAM  : 
    !TYPE     : Subroutine
    !PURPOSE  : 
    !+-----------------------------------------------------------------+
    integer function get_MGXMpath_dimension(Nx_,Ny_)
      integer :: Nx_,Ny_
      get_MGXMpath_dimension = 2*(Nx_/2+1) + (Ny_/2+1)
    end function get_MGXMpath_dimension
    !***************************************************************
    !***************************************************************
    !***************************************************************




    !+-----------------------------------------------------------------+
    !PROGRAM  : 
    !TYPE     : Subroutine
    !PURPOSE  : 
    !+-----------------------------------------------------------------+
    subroutine get_MGXMpath(Nx,Ny,epsik_,ipoint_)
      integer :: ik,ix,iy,Lpath,Nx,Ny
      real(8),dimension(:),intent(inout) :: epsik_
      integer,dimension(4),intent(inout) :: ipoint_

      !a - start from M=(pi,pi) and go to \Gamma=(0,0)
      !b - go from \Gamma(0,0) to X=(pi,0)
      !c - go from X=(pi,0) to M=(pi,pi)
      Lpath=size(epsik_)
      allocate(kgrid_MGXMpath(Lpath))
      allocate(ik2ix_MGXMpath(Lpath),ik2iy_MGXMpath(Lpath))
      allocate(MGXMpath(Lpath))
      ik=0
      ipoint_(1)=0
      do ix=Nx,Nx/2,-1
         iy=ix    !Diagonal condition
         ik=ik+1 ; kgrid_MGXMpath(ik)=kgrid(ix,iy)
         ik2ix_MGXMpath(ik)=ix ; ik2iy_MGXMpath(ik)=iy
      enddo
      ipoint_(2)=ik
      do ix=Nx/2,Nx
         iy=Ny/2   !x-axis condition
         ik=ik+1 ; kgrid_MGXMpath(ik)=kgrid(ix,iy)
         ik2ix_MGXMpath(ik)=ix ; ik2iy_MGXMpath(ik)=iy
      enddo
      ipoint_(3)=ik
      do iy=Ny/2,Ny
         ix=Nx     !y-axis condition
         ik=ik+1 ; kgrid_MGXMpath(ik)=kgrid(ix,iy)
         ik2ix_MGXMpath(ik)=ix ; ik2iy_MGXMpath(ik)=iy
      enddo
      ipoint_(4)=Lpath

      forall(ik=1:Lpath)MGXMpath(ik)=dble(ik)
      forall(ik=1:Lpath)epsik_(ik)=epsk(kgrid_MGXMpath(ik))
      return
    end subroutine get_MGXMpath
    !***************************************************************
    !***************************************************************
    !***************************************************************



    !+-----------------------------------------------------------------+
    !PROGRAM  : 
    !TYPE     : Subroutine
    !PURPOSE  : 
    !+-----------------------------------------------------------------+
    elemental function epsk(ka)
      type(vect2D),intent(in) :: ka
      real(8)                 :: epsk
      real(8)                 :: Kx,Ky
      Kx=ka%x
      Ky=ka%y
      epsk= -2.d0*t_hopping*(cos(Kx) + cos(Ky)) - 4.0*t_prime*(cos(Kx)*cos(Ky))
    end function epsk
    !***************************************************************
    !***************************************************************
    !***************************************************************











    !+-------------------------------------------------------------------+
    !PROGRAM  : 
    !TYPE     : Function
    !PURPOSE  : 
    !+-------------------------------------------------------------------+
    elemental function Velocity(kt)!(ik,ti)
      type(vect2D),intent(in) :: kt
      type(vect2D)            :: Velocity
      Velocity%x = 2.0*t_hopping*sin(kt%x) + 4.0*t_prime*sin(kt%x)*cos(kt%y)
      Velocity%y = 2.0*t_hopping*sin(kt%y) + 4.0*t_prime*cos(kt%x)*sin(kt%y)
    end function Velocity
    !***************************************************************
    !***************************************************************
    !***************************************************************






    !+-----------------------------------------------------------------+
    !PROGRAM  : 
    !TYPE     : Subroutine
    !PURPOSE  : 
    !+-----------------------------------------------------------------+
    subroutine get_DOS(epsk_,file_,wt_,wini,wfin,eps)
      implicit none
      character(len=*) :: file_
      integer,parameter :: M=1024
      integer :: i,ik,Lk_
      real(8),optional :: wini,wfin,eps
      real(8) :: w,peso,wini_,wfin_,dew_,eps_
      complex(8) :: gf,iw
      real(8),dimension(:) :: epsk_
      real(8),dimension(:),optional :: wt_
      wini_=-20.d0;if(present(wini))wini_=wini
      wfin_=20.d0;if(present(wfin))wfin_=wfin
      eps_=0.1d0;if(present(eps))eps_=eps
      Lk_=size(epsk_)
      dew_=abs(wfin_-wini_)/dble(2*M)
      open(70,file=trim(file_))
      do i=1,2*M
         w=wini_ + dble(i-1)*dew_;iw=cmplx(w,eps_)
         gf=(0.d0,0.d0)
         do ik=1,Lk_
            peso=1.d0/Lk_
            if(present(wt_))peso=wt_(ik)
            gf=gf+peso/(iw-epsk_(ik))
         enddo
         write(70,*)w,-aimag(gf)/acos(-1.d0)
      enddo
      close(70)
    end subroutine get_DOS
    !***************************************************************
    !***************************************************************
    !***************************************************************










    !+-----------------------------------------------------------------+
    !PROGRAM  : 
    !TYPE     : Subroutine
    !PURPOSE  : 
    !+-----------------------------------------------------------------+
    subroutine plot_real_lattice(ai,aj,grid)
      integer      :: i,j
      type(vect2D) :: ai,aj
      type(vect2D),dimension(0:,0:) :: grid
      open(30,file='Real.lattice')
      do i=0,size(grid,1)-1
         do j=0,size(grid,2)-1
            write(30,*) grid(i,j)%x,grid(i,j)%y
         enddo
      enddo
      write(30,*)""
      write(30,*)0.d0,0.d0
      write(30,*)""
      write(30,*)ai
      write(30,*)""
      write(30,*)aj
      write(30,*)""
      write(30,*)ai+aj
      write(30,*)""
      write(30,*)(-1.d0)*ai
      write(30,*)""
      write(30,*)(-1.d0)*aj
      write(30,*)""
      write(30,*)(-1.d0)*ai+(-1.d0)*aj
      close(30)
      return
    end subroutine plot_real_lattice
    !***************************************************************
    !***************************************************************
    !***************************************************************






    !+-----------------------------------------------------------------+
    !PROGRAM  : 
    !TYPE     : Subroutine
    !PURPOSE  : 
    !+-----------------------------------------------------------------+
    subroutine plot_reciprocal_lattice(bi,bj,grid)
      integer :: i,j
      type(vect2D) :: bi,bj
      type(vect2D),dimension(0:,0:) :: grid
      open(40,file='Reciprocal.lattice')
      do i=0,size(grid,1)-1
         do j=0,size(grid,2)-1
            write(40,*) grid(i,j)%x,grid(i,j)%y
         enddo
      enddo
      write(40,*)''
      write(40,*)0.d0,0.d0
      write(40,*)''
      write(40,*)bi
      write(40,*)''
      write(40,*)bj
      write(40,*)''
      write(40,*)bi+bj
      write(40,*)''
      write(40,*)(-1.d0)*bi
      write(40,*)''
      write(40,*)(-1.d0)*bj
      write(40,*)''
      write(40,*)(-1.d0)*bi+(-1.d0)*bj
      close(40)
    end subroutine plot_reciprocal_lattice
    !***************************************************************
    !***************************************************************
    !***************************************************************







    !+-----------------------------------------------------------------+
    !PROGRAM  : 
    !TYPE     : Subroutine
    !PURPOSE  : 
    !+-----------------------------------------------------------------+
    subroutine get_reduxGrid_dimension(Lk_,step_,Lkredux_)
      integer               :: count,ik
      integer,intent(inout) :: Lkredux_
      integer,intent(in)    :: Lk_
      integer,intent(in)    :: step_
      if(Lk_ > Lkredux_)then
         count=0
         do ik=1,Lk_,step_
            count=count+1
         enddo
         Lkredux_=count
      else
         Lkredux_=Lk_
      endif
      return
    end subroutine get_reduxGrid_dimension
    !***************************************************************
    !***************************************************************
    !***************************************************************




    !+-----------------------------------------------------------------+
    !PROGRAM  : 
    !TYPE     : Subroutine
    !PURPOSE  : 
    !+-----------------------------------------------------------------+
    subroutine get_reduxGrid_index(Lk_,step_,reduced_index)
      integer,intent(in)                  :: Lk_
      integer,intent(in)                  :: step_
      integer                             :: ik,count
      integer,dimension(:),intent(inout)  :: reduced_index
      count=0
      do ik=1,Lk_,step_
         count=count+1
         reduced_index(count) = ik
      enddo
      return
    end subroutine get_reduxGrid_index
    !***************************************************************
    !***************************************************************
    !***************************************************************






    !+-----------------------------------------------------------------+
    !PROGRAM  : 
    !TYPE     : Subroutine
    !PURPOSE  : 
    !+-----------------------------------------------------------------+
    subroutine get_reduxGrid_epsik(epsik_,reduced_index,reduced_epsik)
      real(8),dimension(:),intent(in)        :: epsik_
      integer,dimension(:),intent(in)        :: reduced_index
      real(8),dimension(size(reduced_index)) :: reduced_epsik
      integer                                :: ik,Lkreduced
      Lkreduced=size(reduced_index)
      forall(ik=1:Lkreduced)reduced_epsik(ik) = epsik_(reduced_index(ik))
      return
    end subroutine get_reduxGrid_epsik
    !***************************************************************
    !***************************************************************
    !***************************************************************

    include "sortEPSIK.f90"

  end module LATTICE
